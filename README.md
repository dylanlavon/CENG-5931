# EXPLORING QUANTUM APPLICATIONS FOR PATHFINDING

The goal of this project is to expand off of what was learned during the development of last semester's
High Performance Computing Architecture class, where pathfinding using A* was explored for the
purpose of path-planning for lunar rovers. This project explores different stategies incorporating
quantum-computing concepts, such as Binary Quadratic Matrices (BQMs), Quadratic Unconstrained
Binary Optimization (QUBOs), and Constraint Satisfaction Problems (CSPs) to optimize pathfinding
applications.

![ceng5931-poster](https://github.com/user-attachments/assets/520da55b-201c-4e78-a8a1-a34d5bc48b52)

### Firstly, ensure you have the prerequisite python packages before running any of the scripts.

Ensure you run this from within the root of the repository.

```
pip install requirements.txt
```

## Using clustering.py

<img width="1739" height="989" alt="Screenshot 2025-07-17 162454" src="https://github.com/user-attachments/assets/1db76f9f-fbc5-4737-80d5-e15e954d825a" />


This script randomly generates an NxN grid whose cells contain a single value from 0 to 4.
- The size of the grid can be changed by updating the variable **N**.
- The number of clusters can be changed by updating the variable **K**.
Execute the script by running:
```
python clustering.py
```

## Using game_theory.py

<img width="721" height="708" alt="Screenshot 2025-07-17 162700" src="https://github.com/user-attachments/assets/8a7117ee-9970-47e6-b247-e663004d7f9a" />

This script creates a 3x3 grid whose cells each contain two different weight values: _terrain_ and
_line_of_sight_. The script compares these two values to decide the best path from the top left to
the bottom right of the grid. The script also looks at a _desired_path_len_ variable, which helps
steer the overall length of the path.

Execute the script by running
```
python game_theory.py
```

## Using D-Wave's Maze Solver

<img width="688" height="555" alt="image" src="https://github.com/user-attachments/assets/cb63f1e2-83f5-4f07-807e-23c9403fb5ed" />

D-Wave has previously published a demo showing how their Ocean SDK and their hardware can be used to
solve mazes using quantum computing. However, their code relies on having an API key to use their
physical quantum hardware. To get around this, I have created a fork of their repo, and updated it
to use the simulated annealer from another one of their packages, **dimod**.

The file **demo.py** contains the variables to configure when running the script. _n_rows_ and 
_n_cols_ defines the width and height of the maze. _start_, _end_, and _walls_ are all definitions
for _edges_ of cells. They are strings with the format "<row>,<col><direction>". _direction_ 
indicates either the _n_ (north) or _w_ (west) edge of the cell.

Execute the script (from within the **maze** subdirectory) by running
```
python demo.py
```

## Using sudoku.py

While this is less applicable to path finding, it is still a good demonstration of utilizing QUBOs.
However, this code is generated by LLMs, and does not run correctly! Further work would need to
be done to make this work. There are plenty of examples of solving sudoku puzzles using QUBOs
out there. This script is meant to be modified by updating the **sudoku_grid** variable with the
starting grid you want to be solved.

Execute the script by running
```
python sudoku.py
```

## Using tsp.py

The Traveling Salesman Problem is a classic optimization problem. This script creates a QUBO to
solve a small version of the travelling salesman problem. The starting data can be modified 
by updating the **distance_matrix** variable. This script was largely made to explore how LLMs
could be used to generate QUBOs, and the scripts to solve them.

Execute the script by running
```
python tsp.py
```
